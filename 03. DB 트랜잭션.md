# DB 트랜잭션
## 1. 정의
- 여러 읽기/쓰기를 논리적으로 하나로 묶음
    - 트랜잭션 시작 -> 여러 쿼리 실행 -> 커밋 또는 롤백
    - 모두 반영(커밋) 또는 모두 반영하지 않거나 (롤백)
    
## 2. 시작 기준
- 트랜잭션 범위는 커넥션 기준이다.
- 개념적으로 미러 메소드에서 하나의 트랜잭션을 사용하고 싶다면, 하나의 커넥션을 사용해야 한다는 의미

## 3. 트랜잭션 전파 
- 여러 메소드 호출이 한 트랜잭션에 묶이도록 하기 위해 필요
    - 예시: 스프링 프레임워크의 트랜젹션 처리
        - 메서드 간에 커넥션 객체를 전달하지 않아도 한 트랜잭션으로 묶어서 실행
    
## 4. 트랜잭션과 외부 연동
- 외부 연동이 섞여 있으면 롤백 처리에 주의
- 서로의 성격이 다르기 때문에 주의가 필요함
- api 호출은 롤백이 되지 않기 때문에 상태를 복구할 수 있는 행위가 필요함 

## 5. 글로벌 트랜잭션
- 2PC (two-phrase commit)
- 두 개 이상 자원(DB, 메시징 큐 등)을 한 트랜잭션으로 처리
    - 각 자원이 2PC 를 지원해야 함
    - 글로벌 트랜잭션 관리자 필요
    - 두 개 이상 자원에 대한 트랜잭션 처리가 쉬워짐
    
- 단, 거의 사용하지 않음 
    - 성능이 떨어짐
    - 마이크로서비스에서는 사용할 수 없음
    
- 다중 자원에 대한 데이터 처리가 팔요하다면 다른 수단 고려 
    - 예사: 이벤트/비동기 메시징
  
## 6. 경쟁 상태 (Race Condition)
- 여러 클라이언트가 같은 데이터에 접근할 때 문제 발생
- 트랜잭션 격리 (Isolation)
    - 트랜잭션을 서로 격리해서 다른 트랜잭션이 영향을 주지 못하게 함
- 가장 쉬운 방법은 트랜잭션을 순서대로 실행
    - 동시 접근 문제 아예 없음
    - 하지만 한 번에 한 개 트랜잭션만 처리하므로 성능(처리량) 저하 기능
- 다양한 격리 수준 지원
    - Read Uncommitted ---> 사실상 사용하지 않음
    - Read Committed
    - Repeatable Read
    - Serializable
  
## 동시성 관련 다양한 문제들
- 커밋되지 않은 데이터 읽기 (dirty read)
- 커밋되지 않은 데이터 덮어쓰기 (dirty write)
- 읽는 동안 데이터 변경 1 (read skew, 읽는 시점에 따라 데이터가 바뀜)
- 변경 유실 (Lost Update, 같은 데이터를 쓸 때 발생)
- 읽는 동안 데이터 변경 2
    - 한 트랜잭션의 결과가 다른 트랜잭션의 쿼리 결과에 영향
    - 깉은 데이터를 쓰지 않았지만 실제로는 경쟁상태

## Read Committed
- dirty read & write 문제를 해결
- 커밋된 데이터만 읽기
    - 커밋된 값과 트랜잭션 진행 중인 값을 따로 보관
- 커밋된 데이터만 덮어쓰기
    - 행(레코드) 단위 잠금 사용
        - 같은 데이터를 수정한 트랜잭션이 끝날 때까지 대기
  
## Repeatable Read
- 트랜잭션 동안 같은 데이터를 읽게 함
- read skew 방지
- 구현 예
    - MVCC (Multi-Version Concurrency Control)
        - 읽는 시점에 특정 버전에 해당하는 데이터만 읽음 
  
## 변경 유실(Lost Update)에 대한 몇 가지 처리 방법
- (1) 원자적 연산 사용
- (2) 명시적인 잠금
- (3) CAS (Compare And Set)

## 원자적(atomic) 연산
- DB가 지원하는 원자적 연산 사용
- 동시 수정 요청에 대해 DB 가 순차적으로 처리
- 사용하고 있는 DB 가 원자적 연산을 지원하는지 확인 필요

## 명시적 잠금
- 조회할 때 수정할 행을 미리 잠금
- select ... for update

## CAS
- 수정할 때 값이 같은지 비교
- 예를들어 버전 컬럼 값을 비교해서 같으면 수정

## Serializable
- 인덱스 잠금이나 조건 기반 잠금 등 사용 
