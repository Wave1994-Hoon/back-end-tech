# 어디 가서 코프링 매우 알은 체하기 정리
## 영상 링크
https://www.youtube.com/watch?v=ewBri47JWII&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9CTech

## 1. 코틀린이란 ?
JVM, 안드로이드, 자바스크립트 및 네이티브를 대상으로 하는 정적 타입 지정 언어

젯브레인즈에서 개발한 오픈 소스 (아파치 라이선스 2.0)

OO 스타일과 FP 스타일 모두 사용할 수 있으며 두 요소를 혼합하여 사용할 수 있다.

간결하고 실용적이며 안전하고 기존 언어와의 상호 운용성을 중시한다. (+ 코루틴)

<br>

### (1) 아이템1. 코틀린 표준 라이브러리를 익히고 사용하라
코틀린 1.3부터 모든 플랫폼에서 사용할 수 있는 kotlin.random.Random이 도입되었다.

더 이상 Random을 사용할지 ThreadLocalRandom을 사용할지 고민할 필요가 없다.

자바와 관련된 import문을 제거할 수 있다.

표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 사용할 수 있다.

```kotlin
// AS-IS
import java.util.Random
import java.util.concurrent.ThreadLocalRandom // JDK 6, 7이면 Random, JDK 8 이상이면 ThreadLocalRandom

Random().nextInt()
ThreadLocalRandom.current().nextInt()

// To BE
import kotlin.random.Random

Random.nextInt() // 스레드 안전. 무엇을 사용할지 고민하지 않아도 된다.
```


왜 코틀린에서 제공하는 Random 스레드 안전할까 ? -> 내부적으로 잘 판단해줌

```kotlin
// Random.kt
private val defaultRandom: Random = defaultPlatformRandom()

internal expect fun defaultPlatformRandom(): Random

// PlatformRandom.kr
@InlineOnly
internal actual inline fun defaultPlatformRandom(): Random = 
	IMPLEMENTATIONS.defaultPlatformRandom()

// JDK8PlatformImplementations.kt (ThreadLocalRandom in JDK 8+)
override fun defaultPlatformRandom(): Random = PlatformThreadLocalRandom()

// PlatformImplementations.kt (java.util.Random in JDK 6,7)
override open fun defaultPlatformRandom(): Random = FallbackThreadLocalRandom()

```

코틀린은 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.

인터페이스를 만족하는 실제 컬렉션이 반환된다. 따라서 플랫폼별 컬렉션을 사용할 수 있다.

즉, 코틀린을 사용할 때는 ArrayList & LinkedList 를 쓸지 고민하는 것이 아니라 읽기 가능아냐 변경 가능하냐만 구분한다.

<br>

## 2. 코프링
### (1) 코틀린 맛보기
![image](https://user-images.githubusercontent.com/60383031/164913132-3dc7eccc-a469-400d-a5e3-3a816d345816.png)

### (2) 누가 더 코틀린스러운가 ?? (자바 코드로 보았을 때)
![image](https://user-images.githubusercontent.com/60383031/164913195-5003a0e9-88e5-4b17-b1bb-f24968385549.png)


차이점 
- @NoNull
- @Nullable
- final

위 관용구들은 코틀린에서는 붙이지 않아도 된다.

자바에서는 의식적으로 저런 안전장치를 신경쓰면서 코딩해야한다.

### (3) 아이템2. 자바로 역컴파일하는 습관을 들여라
코틀린 숙련도를 향상시키는 가장 좋은 방법 중 하나는 작성한 코드가 자바로 어떻게 표현되는지 확인하는 것이다.

역컴파일을 통해 예기치 않은 코드 생성을 방지할 수 있다.

기존 자바 라이브러리와 프레임워크를 사용하며 문제가 발생할 때 빠르게 확인할 수 있다.

inteliJ IDEA에서 Tools > Kotlin > Show Kotlin Bytecode ⇒ Decompile


### (4) 코틀린 컴파일
![image](https://user-images.githubusercontent.com/60383031/164913350-e7f8b76c-a713-43a1-bc75-d126938eca45.png)

### (5) 만약 자바와 같이 사용한다면 ??
![image](https://user-images.githubusercontent.com/60383031/164913444-06a02539-5487-44ba-89e3-2cb3d3f32446.png)

코틀린이 먼저 컴파일된 다음에 자바가 컴파일되는데 그 과정에서 애너테이션 프로세싱이 일어난다.

애너테이션 프로세싱 -> 롬복

### (6) 아이템3. 롬복 대신 데이터 클래스를 사용하라
데이터를 저장하거나 전달하는 것이 주 목적인 클래스를 만드는 경우가 많다. 이러한 클래스의 일부 표준 및 유틸리티 함수는 데이터에서 기계적으로 파생된다.

자바에서는 롬복의 @Data를 사용하여 보일러플레이트 코드를 생성한다.

애너테이션 프로세서는 코틀린 컴파일 이후에 동작하기 때문에 롬복에서 생성된 자바 코드는 코틀린 코드에서 접근할 수 없다.

코틀린 코드보다 자바 코드를 먼저 컴파일하도록 빌드 순서를 조정하면 롬복 문제는 해결할 수 있다. 하지만 자바 코드에서 코틀린 코드를 호출할 수 없게 된다.

#### 데이터 클래스 ???
데이터 클래스를 사용하면 컴파일러가 equals(), hashCode(), toString(), copy() 등을 자동으로 생성해 준다.

주 생성자에는 하나 이상의 매개변수가 있어야 하며 모든 매개변수는 val 또는 var로 표시해야 한다.

copy()를 적절히 사용하면 데이터 클래스를 불변으로 관리할 수 있다.

코드가 간단하기 때문에 한 코틀린 파일에 여러 관련 클래스를 담는 것도 좋은 방법이다.

코틀린 1.5부터 자바16의 레코드 클래스도 지원한다.

![image](https://user-images.githubusercontent.com/60383031/164913757-53bf41e2-bafc-4f15-b500-f5074c646e92.png)






