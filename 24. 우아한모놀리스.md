
## 공유된 데이터 원복의 문제
<img width="600" src="https://user-images.githubusercontent.com/60383031/166254445-470c380d-a54b-459b-8e67-3a4bcde0065c.png">

- 하나의 테이블을 여러개의 서비스가 사용하는 서비스
- 중복된 코드, 안정적이지 않은 코드들을 만날 수 있다.
- 코드가 분산되어 있기 때문에 혼잡하게 동작한다. -> 기능이 복잡하다.
- 기능이 복잡하면, 어떤 비즈니스 요구사항이 들어왔을 때 빨리 반영하지 못한다. 
- 개발 기간이 늘어나고 테스트 기간도 늘어나게 된다.
- 또한 동시에 N 개 이상의 서비스가 동시 배포를 해야한다.
- 정리하자면 원래는 하나의 서비스일 수도 있는게 억지로 찢은거일수도 ??

<br>

## 조직과 시스템 운영 관점
<img width="600" src="https://user-images.githubusercontent.com/60383031/166255442-8a12f01f-73df-49a7-9d5b-2ca6e1c8dc01.png">

- 만약 시간이 부족하다면 일단 빨리 동작하게 만드는데 집중한다. -> 안좋은 구조
- 기술부채를 가속화 시킨다.

<br>

## 대결구도 ??
<img width="600" src="https://user-images.githubusercontent.com/60383031/166256653-c11481d6-0773-4cff-beea-25d8816e4135.png">

- 보통 모놀리틱은 나쁘고 MSA 는 좋다고 말한다.
- MSA 는 넷플릭스와 같은 규모라면 장점이 극대화된다.

<br>

## 모놀리틱 단점
<img width="600" src="https://user-images.githubusercontent.com/60383031/166257447-07093503-e0d0-4912-9da5-43d9a581177e.png">

- 단일 코드 베이스이기 때문에 예상치 못한 결합이 발생할 수 있다.
- 따라서 테스트 비용이 커진다. -> 결합 된 로직 간 테스트가 필요하다.
- 확장은 수평확장 위주로 하는 한계가 존재한다.

<br>

## 마이크로서비스 장점
<img width="600" src="https://user-images.githubusercontent.com/60383031/166257980-d9234de8-016d-406e-8454-959912cf2ac5.png">

- 코네의 법칙: 시스템을 설계하는 조직은 그 조직의 의사소통 구조에 맞춰서 구조화한다.
- 조직의 변화가 생기면 시스템도 변화가 발생해야하지만 그건 좀 어렵다 ...
- 자율적: 스스로 원칙에 따라서 결정을 하고 책임을 가진다.

<br>

## 마이크로서비스가 정답 ??
<img width="600" src="https://user-images.githubusercontent.com/60383031/166259013-f8f7aa87-0cd5-440d-a79c-32be86d3bd12.png">

- 모노리스가 단점을 가지는 이유는 내부의 구조가 복잡하게 엉켜있기 때문이다. (스타게티 코드)

#### 깊게 고민하지 않으면 아래처럼될 확률이 높다.
<img width="600" src="https://user-images.githubusercontent.com/60383031/166262830-8a152c3c-d89b-46d4-940b-a41430e1fc26.png">

- 분산된 모노리스가 되어버린다 ㅎㅎ

<br>

## 따라서 좋은 설계가 먼저다.
<img width="600" src="https://user-images.githubusercontent.com/60383031/166266288-1582de03-1c17-465e-a3f3-9db72f080aea.png">

- 아키텍처 스타일도 중요하지만, 응집과 결합의 원칙도 중요하다.
- 높은 응잡도 & 낮은 결합도 -> 70년대에 소개된 소프트웨어 원칙
- 아키텍처 스타일 & 소프트웨어 설계 원칙과 도구는 복잡성을 제어하기 위해서 나온것이다.

#### 켄트백 왈 
- 응집과 결합을 말할 때, 아래와 같이 이야기함
- 변화의 성격과 비용에 비교를 함
- 응집이라는 것은 시스템에 변경이 필요할 때, 하나의 요소에서 변화하는 정도 (일부분만 바뀐다면 응집도가 낮은거임)
  - 주문의 변경으로 결제가 영향을 받는다면 테스트하면서 검증해야되는 등 영향을 받음 -> 응집도가 낮음
  - 만약 시스템이 거대해지고 주문만 있다면 ?? -> 응집도가 높음


- 결합이라는 것은 두 개 이상의 요소가 있을 때, 하나의 변경이 또 다른 하나의 변경에 미치는 정도
- 만약 서비스를 너무 작은 단위로 쪼개면 -> 서로 변경에 영향을 받을 수 밖에 없다 -> 결합도 높음
- 그렇다고 너무 한 곳으로 모이게 하면 -> 응집도가 낮아진다.
- 즉, 두 개의 밸런스를 잘 유지해야한다. 동시에 두 가지를 모두 잡기는 힘들지만 최대한 잡아야한다.

<br>

## 유연하게 선택 
#### 1. 모놀리스
<img width="600" src="https://user-images.githubusercontent.com/60383031/167429080-be83e980-9269-45da-9813-76a38e780c91.png">

- 단일 프로젝트에 모든 코드가 모여 있어 빠르게 구축 가능

#### 2. 마이크로서비스
<img width="600" src="https://user-images.githubusercontent.com/60383031/167429396-7ba6d80b-3654-40ec-aad1-ea527ab37c38.png">

- 분산 시스템이기 때문에 분산 시스템이 가지는 복잡성을 해결해야 한다,

<br>

## 모듈형모놀리스 
<img width="600" src="https://user-images.githubusercontent.com/60383031/167429764-cb0baf19-02bc-4261-a341-11288b181f12.png">

- 비즈니스 영역에 따라서 독립적인 모듈을 구성하고 서로 협업을 하도록 구성

참고
- https://www.youtube.com/watch?v=VWefNT8Lb74&ab_channel=SpringDeveloperㅊ
- https://gotober.com/2018/sessions/515/modular-monoliths

<br>

## 클린 아키텍처
<img width="600" src="https://user-images.githubusercontent.com/60383031/167431901-12b51119-032b-4e02-96a1-2c3c7f864e88.png">

- MSA <-> 모놀리스 언제든 변환이 가능한 구조여야한다.

<br>

## 모듈화
<img width="600" src="https://user-images.githubusercontent.com/60383031/167432157-fabe43bd-8ceb-428a-8463-aa8d98e1b28e.png">

- 유연한 시스템을 갖추기 위해서 모듈화가 필요하다
- 단일 코드베이스 시스템이 규모가 커졌을 때 경계를 쳐서 복잡성을 줄여주는 도구이다.
- 모듈들을 구성하고 협력시키는 것을 모듈화라고 부르고 자바에서는 패키지로 표현한다.
- 한 번에 다루는 클래스의 개수가 줄어들어 관리에 용이하고, 모듈 내부끼리 응집도를 높힐 수 있다. 모듈끼리는 결합도를 낮춰야한다.

<br>

## 헥사고날 아키텍처 (포토&어댑터 아키텍처)
<img width="600" src="https://user-images.githubusercontent.com/60383031/167432818-0b5711f7-a68f-4cc0-9834-f544f2c59cac.png">

- Application core: 도메인 로직 위치
- Port: 외부와 소통하기 위한 창구 (인터페이스)
- 헥사고날의 핵심은 애플리케이션의 핵심을 외부 기술적인 부분들과 격리시키는 것이다, -> 관심사의 분리





