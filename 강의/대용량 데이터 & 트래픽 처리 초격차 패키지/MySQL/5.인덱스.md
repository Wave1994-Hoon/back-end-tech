## 1. 데이터베이스 성능 핵심
### 1.1 컴퓨터 구조
![image](https://user-images.githubusercontent.com/60383031/218249535-f32e0312-b385-422f-b0d3-39f201350138.png)

-> 데이터베이스 성능 핵심은 디스크 I/O 를 최소화 하는 것

<br>

### 1.2 디스크 접근을 줄이는 법??
메모리에 올라온 데이터로 최대한 요청을 처리 -> 메모리 캐시 히트율 UP

심지어 DB 는 곧 바로 디스크에 쓰지 않고 메모리에 올린다.

메모리 데이터 유실을 고려해 WAL(Write Ahead Log) 를 사용

![image](https://user-images.githubusercontent.com/60383031/218249789-85b9c0f8-f6c1-4e58-bf66-5029f5f58b54.png)

대부분의 트랜잭션은 무작위하게 Write 발생 

이를 디스크에 넣게 되면 랜덤 I/O 가 발생한다. 

WAL 은 파일의 끝 부분에 write 만 하기 때문에 순차 I/O 를 발생시킴

만약 메모리에 있는 데이터가 디스크에 wrtie 하기 전에 죽더라도, 파일을 읽고 원복한다.

<br>

## 2. 인덱스의 기본동작
### 2.1 인덱스 ?
정렬된 자료구조 -> 탐색범위 최소화 

![image](https://user-images.githubusercontent.com/60383031/218250211-a28eece7-e962-4524-a301-daa2c50a7e16.png)

<br>

## 3. 인덱스 자료구조
### 3.1 HashMap ??
- 단 건 검색 속도 O(1)
- 그러나 범위 탐색은 O(N)
- 전방 일치 탐색 불가 ex) like 'AB%' <- 키를 꺼내서 하나하나 비교해야함

<br>

### 3.2 List ??
- 정렬되지 않은 리스트 탐색 O(N)
- 정렬된 리스트의 탐색은 O(logN) <- Binary Search 사용 시
- 정렬되지 않은 리스트의 정렬 시간 복잡도 O(N) ~ O(NlogN)
- 삽입/삭제 비용 매우 높음


### 3.3 Tree
- 트리 높이에 따라 시간 복잡도가 결정
- 트리의 높이를 최소화하는 것이 중요
- 한쪽으로 노트가 치우지지 않도록 균형 잡아주는 트리를 사용한다. 
- ex) Red-Black, B+ <- reb-black 은 노드 수가 고정


-> B tree 는 각 노드가 데이터가 된다. 

-> B+ tree 는 맨 마지막 리프노드에만 데이터가 존재하고 그 외는 키가 된다.

<br>

### 3.4 예제
![image](https://user-images.githubusercontent.com/60383031/218250869-ff7f8343-bf62-410d-83a9-3af641755939.png)

MySQL은 PK 가 클러스터 키라 물고있다. (오라클은 주소)

<br>

## 4. 클러스터 인덱스
### 4.1 클러스터 인덱스란?
- 클러스터 인덱스는 데이터 위치를 결정하는 키 값
- MySQL 의 PK 는 클러스터 인덱스이다.
- MySQL 에서 PK 를 제외한 모든 인덱스는 PK 를 가지고 있다.

<br>

### 4.2 클러스터 키 순서에 따라서 데이터 저장 위치가 변경 
- 클러스터 키 삽입/갱신시에 성능이슈 발생

<br>

### 4.3 PK auto increment vs UUID

<br>

### 4.4 MySQL 에서 PK 를 제외한 모든 인덱스는 PK 를 가지고 있다.
- 인덱스는 모두 PK 를 가지고 있기 때문에, 인덱스의 사이즈를 PK 가 결정한다.

<br>

### 4.5 인덱스가 PK 를 들고 있는 이유
- PK 가 클러스터 인덱스이기 때문에 삽입/삭제 될 떄마다 데이터 주소가 변경 
- 그래서 데이터주소를 직접 들고 있다면, 데이터주소를 갱신해야되서 Pk 를 들고 있는게 이득

<br>

### 4.6 세컨더리 인덱스만으로는 데이터를 찾아갈 수 없다.
- PK 인덱스를 항상 검색해야함

<br>

### 4.7 클러스터링 인덱스 장점
- PK 를 활용한 검색이 빠름, 특히 범위 검색에 유리함
- 세컨더리 인덱스들이 PK 를 가지고 있어 커버링에 유리 
- 커버링: 인덱스까지만 가고 데이터를 내려줌 

